1.声明一个块级作用域 let block = 'only'  在同一个作用域中，不能对同一个变量名进行第二次声明，不管第一次是不是用let声明的
2.声明一个常量 const only = onchange  值不能修改，在同一个作用域中，不能对同一个变量名声明两次
var name = 'kunood'  console.log(window.name == name) //true
let name = 'kunood'  console.log(window.name == name) //false
const name = 'kunood'  console.log(window.name == name) //false
  后面两种都是块级作用域声明方式
  for(var i = 0; i < 10; i++){setTimeout(function(){console.log(i)},1000)}//10个10
  for(let i = 0; i < 10; i++){setTimeout(function(){console.log(i)},1000)}//0-9
  let声明一个块级作用域的 i 第二次执行循环的i 跟第一个i是不同的内存地址

解构：let [first,second..] =arr  如果数组项不足 对应的变量就是undefined
     let [fist,,three,...others] =arr 如果不想取某个值，逗号空出来，...others会接收剩余的项组成一个数组
     let {name,age} = {name:'kunood',age:18}
     let {name:info,age:number} = {name:'kunood',age:18}; 重命名变量，不用加引号，防止某个变量已经声明过，导致报错
     let {name,aga,rank=1080} = {name:'kunood',age:18}  当分配不足时，使用默认值
     
@模板字符串拼接变量 ： `字符串${name}`  反引号包裹全部，${} 解析变量  反引号之间是可以嵌套的
  1.多行字符串，如果使用模板字符串，任何被包裹在两个反引号之间的字符都会被认为是有效的字符串内容，包括换行字符。所以。
    `line1
    line2`//等价于'line1\n' + 'line2'  `line1\nline2`
  2.带标签的模板字符串
    标签使您可以用函数解析模板字符串。标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关
    const = fnName`xxxx`; fnName---function name(stringArr,...values)  ...values ==模板字符串中所有的${} 它是一个数组
    stringArr是一个数组，它包含了模板字符串的普通文本，每一项就是${}隔开的字符串，如果模板字符串的开头或结尾是${},那么它在数组中项的值就是undefined
  3.原始字符串在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串
    

一、变量提升(hoisting)
  js会将当前作用域的所有变量的声明提升到程序的顶部，执行代码js经历编译和执行阶段，而js在编译阶段的时候，会搜集所有的变量声明并且提前声明变量
  即  console.log(name)             编译： var name;
      var name = 'kunood',          执行： console.log(name); name = 'kunood'
  函数声明高于一切，毕竟函数是js的第一公民
        foo(); //编译 var foo; var foo=fn 执行：执行foo()  foo=2
        function foo() {
            console.log('foo'); // foo
        }
        var foo = 2;
       console.log(typeof foo);//number
  Temporal dead zone 暂时性死区  TDZ禁止在未声明之前访问变量
  TDZ影响到的语句  cosnt  let  class语句
  
二、箭头函数
  1.匿名函数 变成箭头函数  去掉function关键字，没有参数空括号+箭头 （)=>{return false}
    一个参数省略括号+箭头  arg=>{return false}
    多个参数逗号隔开+箭头  (arg1,arg2,arg3..)=>{return false}
    如果想将具名函数变成箭头函数 可以使用函数表达式
  2.隐性返回：如果一个函数只想单纯的返回一些数据 可以省略大括号和 return  只留下表达式或值 ()=> n+m
  3.箭头函数的 this 指向 ：箭头函数的this是在定义函数时绑定的，不是在执行过程中绑定的。简单的说，函数在定义时，this就继承了定义函数的对象。
  4.箭头函数不使用场景：当需要重新绑定this值时，不能使用箭头函数
    一个构造函数：实例化一个对象的时候需要将this绑定到当前对象，而箭头函数this不能重新绑定
    当你需要arguments对象时，不能用箭头函数，因为他没有

三、参数默认值
    function sum(a=3,b=4)
   
四、新增的函数 和方法
  str.startsWith(search[,positionIndex]) 
  str.endsWith(search)
  str.includes(serach)
  str.repeat(n)
  
  2.数组方法
  Array.from() 返回一 数组 将类数组对象转换成数组对象，比如arguments Nodelist  Array.from(arguments)  
  const  str = 'hello world'  Array.from(str) //['h','l',...]
  Array.of()返回一个数组，所传的参数，就是数组的项
  
  arr.find(fn) fn的参数 value：数组的项  对数组的每一项调用函数，当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，
  之后的值不会再调用执行函数--在一个数组中寻找复合条件的项
  arr.findIndex() 在一个数组中寻找复合条件的项的索引
  
新的遍历 for(let value of  arr)
  1.直接遍历数组项的值，但是只是遍历数字索引的项
  2.相对于foreach的不能跳过和终止， for of  可以的
  3.不能遍历对象
  
可扩展运算符
  扩展运算符是三个点（...）。用于取出参数对象的所有可遍历属性，然后拷贝到当前对象之中
  如果你执行 const arr2 = arr1 你修改arr2，arr1也会变，你可以这样 const arr2 = [...arr1]
  在参数中使用，function(...arg) 将一个对象的可遍历属性遍历传参
  
对象字面量的新特性
  1.属性简写：  当你的对象的 keyName == valueName  比如 {name:name} 简写 {name}
  2.方法简写：send:function(){}  ==> send(){}
  3.对象的计算属性  {[]:xx}  [] 就相当于模板字符串的${} 里面可使用变量、表达式
  
Promise：
  1.promise 解决了异步请求的回调地狱
  2.let ajaxs = new Promise((resolve,reject)=>{
              //请求...
              if(respon){ 
                resolve(data) //请求成功 调用内置的reslove()函数
               }else{
                 reject(msgerr)//请求失败，调用reject()函数
  })
  
 3.对请求的最终结果进行监听
   ajaxs.then(data=>{xx}).catch(err=>{xxx})
 Promise.all方法用来包装许多个Promise实例，然后组成了一个新的Promise对象，新的Promise对象的状态由前面几个被包裹的Promise对象的状态决定，
 如果前面的Promise都被resolve了，那么新的Promise的状态也是resolve的；只要有一个Promise被reject了，那么组成的新的Promise的状态也是reject的。
 
 Promise.race方法和上面的Promise.all有点类似，都是包装许多的Promise对象，然后组成了一个新的Promise对象，但是使用Promise.race的含义是：
 只要包裹的的Promise对象中有一个的状态发生了改变那么组成的这个新的Promise对象的状态就是上面那个率先改变的Promise实例的状态。

新变量：symbol 生成一个唯一的标志符， 为了解决对象属性名的冲突
  1. let lisi = Symbol('lisi');
  2. 如果对象有个Symbol类型的属性，那这个属性不是可枚举属性，不能像平常属性一样访问 synobj[Object.getOwnPropertySymbols(synobj)[0]]
  
  
